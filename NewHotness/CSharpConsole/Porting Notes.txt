=============================================================================
Aliases
=============================================================================

opus_uint32	uint
opus_int32	int
opus_uint16	ushort
opus_int16	short
opus_uint8	byte
opus_int8	sbyte
opus_int	int
silk_float	float
opus_val32	float
opus_val16	float
celt_sig	float
celt_norm	float
kiss_fft_scalar	float


Replace CELTEncoder with OpusCustomEncoder
Replace CELTDecoder with OpusCustomDecoder
Replace CELTMode with OpusCustomMode


#define celt_encoder_ctl opus_custom_encoder_ctl
#define celt_decoder_ctl opus_custom_decoder_ctl

=============================================================================
General guidance
=============================================================================

Remove runtime arch references

"const" function params change to "in" (not necessary but whatever, it preserves semantics)

Any calls to SILK memset, memcpy, etc. must reconcile bytes vs. elements to copy

VARDECL + ALLOC turns into regular heap array allocation + pinning if necessary

Remove _c from generic unaccelerated functions (for now, until I can revisit vector implementations)

SILK_DWORD_ALIGN is an aligned alloc to 4 byte bounds; I assume C# should respect this by default

=============================================================================
Function signatures and classes
=============================================================================

internal static unsafe 


=============================================================================
Common Silk includes
=============================================================================
using System;
using static HellaUnsafe.Common.CRuntime;
using static HellaUnsafe.Silk.Define;
using static HellaUnsafe.Silk.Inlines;
using static HellaUnsafe.Silk.Macros;
using static HellaUnsafe.Silk.SigProcFIX;
using static HellaUnsafe.Silk.Structs;
using static HellaUnsafe.Silk.Tables;


=============================================================================
Stackalloc arrays
=============================================================================
int a_fix_Q16[MAX_LPC_ORDER];


becomes


int* a_fix_Q16 = stackalloc int[MAX_LPC_ORDER]

or

Span<int> a_fix_Q16 = stackalloc int[MAX_LPC_ORDER]






=============================================================================
Arrays of embedded structs using InlineArrays
=============================================================================

// Original C:
// SideInfoIndices indices_LBRR[ MAX_FRAMES_PER_PACKET ];


[System.Runtime.CompilerServices.InlineArray(MAX_NB_FRAMES)]
public struct SideInfoIndicesArray
{
    private SideInfoIndices _element;
}

public unsafe struct Encoder
{
    private SideInfoIndicesArray _indices_LBRR;
    public TestSideInfoIndices* indices_LBRR => (SideInfoIndices*)Unsafe.AsPointer(ref _indices_LBRR); // assumes caller struct is already fixed
}




=============================================================================
Same thing without use of InlineArray - just use field duplication
=============================================================================

public unsafe struct Encoder
{
    private TestSideInfoIndices _indices_LBRR0;
    private TestSideInfoIndices _indices_LBRR1;
    private TestSideInfoIndices _indices_LBRR2;

    public TestSideInfoIndices* indices_LBRR => (TestSideInfoIndices*)Unsafe.AsPointer(ref _indices_LBRR0);
}





=============================================================================
2D arrays embedded in structs, with accessor (accessor assumes struct is already pinned)
=============================================================================

// Original C:
// opus_int8 pulses_LBRR[ MAX_FRAMES_PER_PACKET ][ MAX_FRAME_LENGTH ];

public unsafe struct Encoder
{
    private fixed sbyte _pulses_LBRR[MAX_FRAMES_PER_PACKET * MAX_FRAME_LENGTH];
    public Native2DArray<sbyte> pulses_LBRR => new Native2DArray<sbyte>(MAX_FRAMES_PER_PACKET, MAX_FRAME_LENGTH, (sbyte*)Unsafe.AsPointer(ref _pulses_LBRR[0]));
}


=============================================================================
Statically allocated pointer arrays
=============================================================================


internal static readonly sbyte** silk_LTP_vq_ptrs_Q7 = AllocateGlobalPointerArray<sbyte>(NB_LTP_CBKS, new sbyte*[]
{
    &silk_LTP_gain_vq_0[0][0],
    &silk_LTP_gain_vq_1[0][0],
    &silk_LTP_gain_vq_2[0][0]
});



=============================================================================
Static data arrays
=============================================================================

1D

internal static readonly sbyte* layer0_weights = AllocateGlobalArray<sbyte>(800, new sbyte[] {
           -30, -9, 2, -12, 5, -1, 8, 9
		   });
		   
2D

internal static readonly Native2DArray<byte> silk_gain_iCDF = new Native2DArray<byte>(3, N_LEVELS_QGAIN / 8, new byte[]
{
    //{
       224,    112,     44,     15,      3,      2,      1,      0,
    //},
    //{
       254,    237,    192,    132,     70,     23,      4,      0,
    //},
    //{
       255,    252,    226,    155,     61,     11,      2,      0,
    //}
});

3D

internal static readonly Native3DArray<byte> e_prob_model = new Native3DArray<byte>(4, 2, 42, new byte[] {