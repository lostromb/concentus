=============================================================================
Aliases
=============================================================================

opus_uint32	uint
opus_int32	int
opus_uint16	ushort
opus_int16	short
opus_uint8	byte
opus_int8	sbyte
opus_val16	float
opus_int	int
silk_float	float


=============================================================================
General guidance
=============================================================================

Remove runtime arch references

"const" function params change to "in" (not necessary but whatever, it preserves semantics)

Any calls to SILK memset, memcpy, etc. must reconcile bytes vs. elements to copy

VARDECL + ALLOC turns into regular heap array allocation + pinning if necessary

Remove _c from generic unaccelerated functions (for now, until I can revisit vector implementations)

=============================================================================
Function signatures and classes
=============================================================================

internal static unsafe 


=============================================================================
Common Silk includes
=============================================================================
using System;
using static HellaUnsafe.Common.CRuntime;
using static HellaUnsafe.Silk.Define;
using static HellaUnsafe.Silk.Macros;
using static HellaUnsafe.Silk.SigProcFIX;
using static HellaUnsafe.Silk.Structs;
using static HellaUnsafe.Silk.Float.SigProcFLP;
using static HellaUnsafe.Silk.Float.Structs_FLP;


=============================================================================
Stackalloc arrays
=============================================================================
int a_fix_Q16[MAX_LPC_ORDER];


becomes


int* a_fix_Q16 = stackalloc int[MAX_LPC_ORDER]

or

Span<int> a_fix_Q16 = stackalloc int[MAX_LPC_ORDER]






=============================================================================
Arrays of embedded structs using InlineArrays
=============================================================================

// Original C:
// SideInfoIndices indices_LBRR[ MAX_FRAMES_PER_PACKET ];


[System.Runtime.CompilerServices.InlineArray(MAX_NB_FRAMES)]
public struct SideInfoIndicesArray
{
    private SideInfoIndices _element;
}

public unsafe struct Encoder
{
    private SideInfoIndicesArray _indices_LBRR;
    public TestSideInfoIndices* indices_LBRR => (SideInfoIndices*)Unsafe.AsPointer(ref _indices_LBRR); // assumes caller struct is already fixed
}




=============================================================================
Same thing without use of InlineArray - just use field duplication
=============================================================================

public unsafe struct Encoder
{
    private TestSideInfoIndices _indices_LBRR0;
    private TestSideInfoIndices _indices_LBRR1;
    private TestSideInfoIndices _indices_LBRR2;

    public TestSideInfoIndices* indices_LBRR => (TestSideInfoIndices*)Unsafe.AsPointer(ref _indices_LBRR0);
}





=============================================================================
2D arrays embedded in structs, with accessor (accessor assumes struct is already pinned)
=============================================================================

// Original C:
// opus_int8 pulses_LBRR[ MAX_FRAMES_PER_PACKET ][ MAX_FRAME_LENGTH ];

public unsafe struct Encoder
{
    private fixed sbyte _pulses_LBRR[MAX_FRAMES_PER_PACKET * MAX_FRAME_LENGTH];
    public Native2DArray<sbyte> pulses_LBRR => new Native2DArray<sbyte>((sbyte*)Unsafe.AsPointer(ref _pulses_LBRR[0]), MAX_FRAMES_PER_PACKET, MAX_FRAME_LENGTH);
}